<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-02-07T02:28:18.982Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>进程、线程、协程｜协程池是否必要</title>
    <link href="http://example.com/2025/02/06/golang/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%EF%BD%9C%E5%8D%8F%E7%A8%8B%E6%B1%A0%E6%98%AF%E5%90%A6%E5%BF%85%E8%A6%81/"/>
    <id>http://example.com/2025/02/06/golang/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%EF%BD%9C%E5%8D%8F%E7%A8%8B%E6%B1%A0%E6%98%AF%E5%90%A6%E5%BF%85%E8%A6%81/</id>
    <published>2025-02-06T04:12:59.648Z</published>
    <updated>2025-02-07T02:28:18.982Z</updated>
    
    <content type="html"><![CDATA[<p>首先分别看下进程、线程、协程的定义：</p><ol><li>进程：每个进程都有自己的独立内存空间，拥有自己独立的地址空间、独立的堆和栈，既不共享堆，亦不共享栈。一个程序至少有一个进程，一个进程至少有一个线程。进程切换只发生在内核态。</li><li>线程：拥有自己独立的栈，共享堆内存数据。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先分别看下进程、线程、协程的定义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进程：每个进程都有自己的独立内存空间，拥有自己独立的地址空间、独立的堆和栈，既不共享堆，亦不共享栈。一个程序至少有一个进程，一个进程至少有一个线程。进程切换只发生在内核态。&lt;/li&gt;
&lt;li&gt;线程：拥有自己独立</summary>
      
    
    
    
    <category term="golang" scheme="http://example.com/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>rpc相较于http的优势</title>
    <link href="http://example.com/2024/12/23/%E9%A1%B9%E7%9B%AE/rpc%E7%9B%B8%E8%BE%83%E4%BA%8Ehttp%E7%9A%84%E4%BC%98%E5%8A%BF/"/>
    <id>http://example.com/2024/12/23/%E9%A1%B9%E7%9B%AE/rpc%E7%9B%B8%E8%BE%83%E4%BA%8Ehttp%E7%9A%84%E4%BC%98%E5%8A%BF/</id>
    <published>2024-12-23T03:58:09.082Z</published>
    <updated>2025-02-20T07:57:16.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rpc介绍"><a href="#rpc介绍" class="headerlink" title="rpc介绍"></a>rpc介绍</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;rpc介绍&quot;&gt;&lt;a href=&quot;#rpc介绍&quot; class=&quot;headerlink&quot; title=&quot;rpc介绍&quot;&gt;&lt;/a&gt;rpc介绍&lt;/h1&gt;</summary>
      
    
    
    
    <category term="项目" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>docker镜像体积优化</title>
    <link href="http://example.com/2024/12/20/kubernetes/docker%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2024/12/20/kubernetes/docker%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96/</id>
    <published>2024-12-20T14:43:51.176Z</published>
    <updated>2024-12-20T14:44:10.221Z</updated>
    
    
    
    
    <category term="kubernetes" scheme="http://example.com/categories/kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>项目https协议</title>
    <link href="http://example.com/2024/12/18/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AEhttps%E5%8D%8F%E8%AE%AE/"/>
    <id>http://example.com/2024/12/18/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AEhttps%E5%8D%8F%E8%AE%AE/</id>
    <published>2024-12-18T13:09:17.665Z</published>
    <updated>2025-02-21T06:09:59.096Z</updated>
    
    <content type="html"><![CDATA[<p>证书：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;证书：&lt;/p&gt;
</summary>
      
    
    
    
    <category term="项目" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>排序技巧</title>
    <link href="http://example.com/2024/12/16/golang/%E6%8E%92%E5%BA%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://example.com/2024/12/16/golang/%E6%8E%92%E5%BA%8F%E6%8A%80%E5%B7%A7/</id>
    <published>2024-12-16T01:49:44.287Z</published>
    <updated>2024-12-16T10:44:06.713Z</updated>
    
    <content type="html"><![CDATA[<p>要善用sort包</p><p>首先看下之前在堆排序文章中讲的sort接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Interface interface &#123;</span><br><span class="line">Len() int</span><br><span class="line">Less(i, j int) bool</span><br><span class="line">Swap(i, j int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<br>你可以定义一个实现了这个接口的类型</p><p>然后比如可以把这个</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;要善用sort包&lt;/p&gt;
&lt;p&gt;首先看下之前在堆排序文章中讲的sort接口&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/sp</summary>
      
    
    
    
    <category term="golang" scheme="http://example.com/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>gorm笔记</title>
    <link href="http://example.com/2024/12/11/%E6%95%B0%E6%8D%AE%E5%BA%93/gorm%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/12/11/%E6%95%B0%E6%8D%AE%E5%BA%93/gorm%E7%AC%94%E8%AE%B0/</id>
    <published>2024-12-11T02:53:04.019Z</published>
    <updated>2025-02-14T07:20:25.509Z</updated>
    
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>kafka论文解读</title>
    <link href="http://example.com/2024/12/01/web%E5%BC%80%E5%8F%91/kafka%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/"/>
    <id>http://example.com/2024/12/01/web%E5%BC%80%E5%8F%91/kafka%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/</id>
    <published>2024-12-01T14:00:52.258Z</published>
    <updated>2024-12-01T14:10:25.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="架构详解"><a href="#架构详解" class="headerlink" title="架构详解"></a>架构详解</h2><p>相比rabbitmq等 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;架构详解&quot;&gt;&lt;a href=&quot;#架构详解&quot; class=&quot;headerlink&quot; title=&quot;架构详解&quot;&gt;&lt;/a&gt;架构详解&lt;/h2&gt;&lt;p&gt;相比rabbitmq等
 &lt;/p&gt;
</summary>
      
    
    
    
    <category term="web开发" scheme="http://example.com/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>git笔记</title>
    <link href="http://example.com/2024/11/25/%E9%9A%8F%E7%AC%94/git%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/11/25/%E9%9A%8F%E7%AC%94/git%E7%AC%94%E8%AE%B0/</id>
    <published>2024-11-25T02:36:43.116Z</published>
    <updated>2024-11-25T06:10:37.177Z</updated>
    
    <content type="html"><![CDATA[<p>撤销尚未add的修改：<br>git checkout – filepath</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;撤销尚未add的修改：&lt;br&gt;git checkout – filepath&lt;/p&gt;
</summary>
      
    
    
    
    <category term="goframe框架" scheme="http://example.com/categories/goframe%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>堆结构详解-golang</title>
    <link href="http://example.com/2024/11/25/golang/%E5%A0%86%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2024/11/25/golang/%E5%A0%86%E5%AE%9E%E7%8E%B0/</id>
    <published>2024-11-25T01:50:09.545Z</published>
    <updated>2025-02-26T07:27:17.451Z</updated>
    
    <content type="html"><![CDATA[<p>golang没有像java一样提供容器类<br>想要实现堆，要实现heap接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">sort.Interface</span><br><span class="line">Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// add x as element Len()</span></span><br><span class="line">Pop() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// remove and return element Len() - 1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现push和pop，还要实现sort接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package sort provides primitives for sorting slices and user-defined</span></span><br><span class="line"><span class="comment">// collections.</span></span><br><span class="line"><span class="keyword">package</span> sort</span><br><span class="line"></span><br><span class="line"><span class="comment">// A type, typically a collection, that satisfies sort.Interface can be</span></span><br><span class="line"><span class="comment">// sorted by the routines in this package. The methods require that the</span></span><br><span class="line"><span class="comment">// elements of the collection be enumerated by an integer index.</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">Len() <span class="type">int</span></span><br><span class="line"><span class="comment">// Less reports whether the element with</span></span><br><span class="line"><span class="comment">// index i should sort before the element with index j.</span></span><br><span class="line">Less(i, j <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line"><span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">Swap(i, j <span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;golang没有像java一样提供容器类&lt;br&gt;想要实现堆，要实现heap接口&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;b</summary>
      
    
    
    
    <category term="golang" scheme="http://example.com/categories/golang/"/>
    
    
    <category term="golang" scheme="http://example.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2024/11/23/redis%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>http://example.com/2024/11/23/redis%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7/</id>
    <published>2024-11-23T13:53:58.150Z</published>
    <updated>2024-11-27T07:49:01.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>读取数据的情况比较简单，先读redis，redis没有的话，再读数据库，之后将数据更新到redis<br><img   src="https://blog-picture-a.oss-cn-shanghai.aliyuncs.com/20241123224837.png"  alt="image.png"></p><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>其实写请求，才是造成大多数一致性问题的原因<br>一般来说，针对写请求有四个策略</p><ul><li>更新数据库后更新缓存</li><li>更新数据库前更新缓存</li><li>更新数据库前删除缓存</li><li>更新数据库后删除缓存<br>接来来，我们分别说一下这四种情况</li></ul><h4 id="先更新数据库后更新缓存"><a href="#先更新数据库后更新缓存" class="headerlink" title="先更新数据库后更新缓存"></a>先更新数据库后更新缓存</h4><table><thead><tr><th>时间</th><th>线程A（写请求）</th><th>线程B（写请求）</th><th>问题</th></tr></thead><tbody><tr><td>T1</td><td>更新数据库为99</td><td></td><td></td></tr><tr><td>T2</td><td></td><td>更新数据库为98</td><td></td></tr><tr><td>T3</td><td></td><td>更新缓存数据为98</td><td></td></tr><tr><td>T4</td><td>更新缓存数据为99</td><td></td><td>此时缓存的值被显式更新为99，但是实际上数据库的值已经是98，数据不一致</td></tr></tbody></table><h4 id="先更新缓存再更新数据库"><a href="#先更新缓存再更新数据库" class="headerlink" title="先更新缓存再更新数据库"></a>先更新缓存再更新数据库</h4><p>这是最不靠谱的一种方案</p><p>因为更新数据库不一定成功，如果数据库没有更新成功，那么读到的就不是脏数据了，而是<code>错误数据</code>了</p><h4 id="先删除缓存再更新数据库"><a href="#先删除缓存再更新数据库" class="headerlink" title="先删除缓存再更新数据库"></a>先删除缓存再更新数据库</h4><p>这么做，写写并发的时候没有问题，但是读写并发的时候有问题</p><table><thead><tr><th>时间</th><th>线程A（写请求）</th><th>线程B（读请求）</th><th>问题</th></tr></thead><tbody><tr><td>T1</td><td>删除缓存值</td><td></td><td></td></tr><tr><td>T2</td><td></td><td>1.读取缓存数据，缓存缺失，从数据库读取数据100</td><td></td></tr><tr><td>T3</td><td>更新数据库中的数据X的值为99</td><td></td><td></td></tr><tr><td>T4</td><td></td><td>将数据100的值写入缓存</td><td>此时缓存的值被显式更新为100，但是实际上数据库的值已经是99了</td></tr><tr><td>针对这种场景，有个做法是所谓的<strong>“延迟双删策略”</strong>，就是说，既然可能因为读请求把一个旧的值又写回去，那么我在写请求处理完之后，等到差不多的时间延迟再重新删除这个缓存值。</td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>时间</th><th>线程A（写请求）</th><th>线程C（新的读请求）</th><th>线程D（新的读请求）</th><th>问题</th></tr></thead><tbody><tr><td>T5</td><td>sleep(N)</td><td>缓存存在，读取到缓存旧值100</td><td></td><td>其他线程可能在双删成功前读到脏数据</td></tr><tr><td>T6</td><td>删除缓存值</td><td></td><td></td><td></td></tr><tr><td>T7</td><td></td><td></td><td>缓存缺失，从数据库读取数据的最新值（99）</td><td></td></tr><tr><td>如果N的时间设置得太短，那么删除缓存还是在读线程C更新缓存之前，那么还是脏数据</td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="先更新数据库后删除缓存"><a href="#先更新数据库后删除缓存" class="headerlink" title="先更新数据库后删除缓存"></a>先更新数据库后删除缓存</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;读取数据&quot;&gt;&lt;a href=&quot;#读取数据&quot; class=&quot;headerlink&quot; title=&quot;读取数据&quot;&gt;&lt;/a&gt;读取数据&lt;/h2&gt;&lt;p&gt;读取数据的情况比较简单，先读redis，redis没有的话，再读数据库，之后将数据更新到redis&lt;br&gt;&lt;img   sr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2024/11/20/Mysql%E8%A1%A8%E8%BF%9E%E6%8E%A5/"/>
    <id>http://example.com/2024/11/20/Mysql%E8%A1%A8%E8%BF%9E%E6%8E%A5/</id>
    <published>2024-11-20T06:49:24.071Z</published>
    <updated>2024-11-20T06:49:42.334Z</updated>
    
    <content type="html"><![CDATA[<p>等值连接</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;等值连接&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mysql是怎样运行的｜第一章</title>
    <link href="http://example.com/2024/11/19/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%EF%BD%9C%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>http://example.com/2024/11/19/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%EF%BD%9C%E7%AC%AC%E4%B8%80%E7%AB%A0/</id>
    <published>2024-11-19T10:56:32.561Z</published>
    <updated>2025-02-14T07:20:47.436Z</updated>
    
    
    
    
    <category term="mysql" scheme="http://example.com/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>Go的slice</title>
    <link href="http://example.com/2024/11/16/golang/Go%E7%9A%84slice/"/>
    <id>http://example.com/2024/11/16/golang/Go%E7%9A%84slice/</id>
    <published>2024-11-16T04:58:43.992Z</published>
    <updated>2025-02-21T09:33:32.361Z</updated>
    
    <content type="html"><![CDATA[<p>go的切片，slice[2:4],左闭右开</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;go的切片，slice[2:4],左闭右开&lt;/p&gt;
</summary>
      
    
    
    
    <category term="golang" scheme="http://example.com/categories/golang/"/>
    
    
    <category term="golang" scheme="http://example.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>IDE配置</title>
    <link href="http://example.com/2024/10/22/%E9%9A%8F%E7%AC%94/IDE%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2024/10/22/%E9%9A%8F%E7%AC%94/IDE%E9%85%8D%E7%BD%AE/</id>
    <published>2024-10-22T07:27:41.884Z</published>
    <updated>2025-02-21T11:05:40.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h2><p>打开github copilot chat ：cmd+ctrl+I<br>cw 快速修改文本</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Cmd+D(gb)</td><td>选择下一个匹配项，也是选择光标所在单词</td></tr><tr><td>Cmd+K Cmd+D</td><td>跳过当前选择项</td></tr><tr><td>cmd+u</td><td>回到上一个</td></tr><tr><td>cmd+shift+space</td><td>函数提示</td></tr><tr><td>cmd+option+i</td><td>结构体字段提示</td></tr><tr><td>shift+方向键</td><td>分屏跳转</td></tr><tr><td>cmd+shift+L</td><td>多选</td></tr></tbody></table><h2 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h2><p>同时选中修改cmd+f<br>聚焦到编辑器 esc<br>聚焦到project：cmd+1</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;vscode&quot;&gt;&lt;a href=&quot;#vscode&quot; class=&quot;headerlink&quot; title=&quot;vscode&quot;&gt;&lt;/a&gt;vscode&lt;/h2&gt;&lt;p&gt;打开github copilot chat ：cmd+ctrl+I&lt;br&gt;cw 快速修改文本&lt;/p&gt;
&lt;ta</summary>
      
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>正向代理、反向代理、reverseproxy</title>
    <link href="http://example.com/2024/10/17/web%E5%BC%80%E5%8F%91/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81reverseproxy/"/>
    <id>http://example.com/2024/10/17/web%E5%BC%80%E5%8F%91/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81reverseproxy/</id>
    <published>2024-10-17T01:54:56.280Z</published>
    <updated>2024-10-18T03:11:22.089Z</updated>
    
    <content type="html"><![CDATA[<p>这里说下我理解的正反向代理与golang的reverse_proxy如何实现代理</p><h2 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h2><p>正向代理与反向代理的核心区别在于其目的（或者说作用的对象）</p><ul><li>正向代理：帮客户端进行请求代理，发给服务器</li><li>反向代理，帮服务端处理</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里说下我理解的正反向代理与golang的reverse_proxy如何实现代理&lt;/p&gt;
&lt;h2 id=&quot;正向代理与反向代理&quot;&gt;&lt;a href=&quot;#正向代理与反向代理&quot; class=&quot;headerlink&quot; title=&quot;正向代理与反向代理&quot;&gt;&lt;/a&gt;正向代理与反向代理&lt;/</summary>
      
    
    
    
    <category term="web开发" scheme="http://example.com/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>go work实践</title>
    <link href="http://example.com/2024/10/09/golang/go%20work%E5%AE%9E%E8%B7%B5/"/>
    <id>http://example.com/2024/10/09/golang/go%20work%E5%AE%9E%E8%B7%B5/</id>
    <published>2024-10-09T03:29:26.006Z</published>
    <updated>2024-10-09T03:33:49.817Z</updated>
    
    <content type="html"><![CDATA[<p>go work在1.18引入<br>旨在解决本地开发多module场景，传统的go module不优雅的问题</p><p>1.18之前</p><ul><li>当go.mod中引用的moudle未在github发布，那么go mod tidy时候会报错（多moudle开发的时候经常会遇到这个问题）</li><li>需要在go.mod文件中进行replace替换成本地包，但是push的时候，有需要将其修改回来<br>引入工作区模式之后：</li><li>不需要在go.mod中替换，在go.work文件中替换即可</li><li>go.work文件不提交到代码库</li></ul><p>需要注意的是</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;go work在1.18引入&lt;br&gt;旨在解决本地开发多module场景，传统的go module不优雅的问题&lt;/p&gt;
&lt;p&gt;1.18之前&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当go.mod中引用的moudle未在github发布，那么go mod tidy时候会报错（多moudle开</summary>
      
    
    
    
    <category term="golang" scheme="http://example.com/categories/golang/"/>
    
    
    <category term="golang" scheme="http://example.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>三剑客（pflag、viper、cobra）实践</title>
    <link href="http://example.com/2024/09/13/golang/%E4%B8%89%E5%89%91%E5%AE%A2%EF%BC%88pflag%E3%80%81viper%E3%80%81cobra%EF%BC%89%E5%AE%9E%E8%B7%B5/"/>
    <id>http://example.com/2024/09/13/golang/%E4%B8%89%E5%89%91%E5%AE%A2%EF%BC%88pflag%E3%80%81viper%E3%80%81cobra%EF%BC%89%E5%AE%9E%E8%B7%B5/</id>
    <published>2024-09-13T10:59:43.715Z</published>
    <updated>2025-02-21T09:48:55.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pflag"><a href="#pflag" class="headerlink" title="pflag"></a>pflag</h2><p>比较推荐使用pflag默认提供的flagset-&gt;CommandLine</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String defines a string flag with specified name, default value, and usage string.</span></span><br><span class="line"><span class="comment">// The return value is the address of a string variable that stores the value of the flag.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">String</span><span class="params">(name <span class="type">string</span>, value <span class="type">string</span>, usage <span class="type">string</span>)</span></span> *<span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> CommandLine.StringP(name, <span class="string">&quot;&quot;</span>, value, usage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">name   = pflag.String(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;pcas-aim-be&quot;</span>, <span class="string">&quot;name of the service&quot;</span>)</span><br><span class="line">help   = pflag.Bool(<span class="string">&quot;help&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;if print help&quot;</span>)</span><br><span class="line">config = pflag.String(<span class="string">&quot;config&quot;</span>, <span class="string">&quot;/etc/pcas-aim-be/config.yaml&quot;</span>, <span class="string">&quot;config file&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>因此直接使用变量即可<br>同样也可以自定义flagset</p><h2 id="Viper"><a href="#Viper" class="headerlink" title="Viper"></a>Viper</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;pflag&quot;&gt;&lt;a href=&quot;#pflag&quot; class=&quot;headerlink&quot; title=&quot;pflag&quot;&gt;&lt;/a&gt;pflag&lt;/h2&gt;&lt;p&gt;比较推荐使用pflag默认提供的flagset-&amp;gt;CommandLine&lt;/p&gt;
&lt;figure class=</summary>
      
    
    
    
    <category term="golang" scheme="http://example.com/categories/golang/"/>
    
    
    <category term="golang" scheme="http://example.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang包管理</title>
    <link href="http://example.com/2024/09/09/golang/golang%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2024/09/09/golang/golang%E5%8C%85%E7%AE%A1%E7%90%86/</id>
    <published>2024-09-09T07:29:30.736Z</published>
    <updated>2024-12-18T08:45:14.047Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下go moudle相关内容</p><p>golang的包管理经历了GOPATH、go vendor、go moudle三个阶段</p><h3 id="GOPATH机制"><a href="#GOPATH机制" class="headerlink" title="GOPATH机制"></a>GOPATH机制</h3><p>golang的package主要分为三种</p><ul><li>标准库</li><li>第三方库</li><li>项目私库<br>项目会放在GOPATH&#x2F;src目录下<br>这种方式有一个问题，就是当你有两个项目A、B依赖了同一个第三方库C的不同版本，只能维护两个GOPATH</li></ul><blockquote><p>由于编译器依赖查找固定从GOPATH&#x2F;src下查找<code>GOPATH/src/T</code>，所以，无法在同一个GOPATH目录下保存第三方库T的两个版本</p></blockquote><p>为了解决这个问题，引入GOVENDOR机制</p><h3 id="go-vendor"><a href="#go-vendor" class="headerlink" title="go vendor"></a>go vendor</h3><p>go vendor机制将依赖放在项目目录中，从而隔离了不同项目，不同项目可以引用同一个第三方库的不同版本。<br>但是这会导致两个问题</p><p>比如：项目A中依赖了B、C两个第三方库，而B也依赖了C这个库，就会到导致两个问题：</p><ol><li>C被两次编译进A项目的可执行文件</li><li>再进一步，如果两个C的版本不一致，也会有兼容性问题</li></ol><h3 id="go-moudle"><a href="#go-moudle" class="headerlink" title="go moudle"></a>go moudle</h3><p>在go1.11版本中引入了go moudle机制，它采用了一种全新的设计思想</p><p>通过go.mod文件实现</p><ol><li>准确地记录项目依赖</li><li>可重复构建</li></ol><p>核心是把项目及其依赖抽象成moudle</p><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p>replace用于替换require中出现的包</p><p>它正常工作还需要满足两个条件：<br>第一，<code>replace</code>仅在当前module为<code>main module</code>时有效，比如我们当前在编译<code>github.com/renhongcai/gomodule</code>，此时就是<code>main module</code>，如果其他项目引用了<code>github.com/renhongcai/gomodule</code>，那么其他项目编译时，<code>replace</code>就会被自动忽略。</p><p>第二，<code>replace</code>指定中<code>=&gt;</code>前面的包及其版本号必须出现在<code>require</code>中才有效，否则指令无效，也会被忽略。 比如，上面的例子中，我们指定<code>replace github.com/google/uuid =&gt; github.com/google/uuid v1.1.0</code>，或者指定<code>replace github.com/google/uuid v1.0.9 =&gt; github.com/google/uuid v1.1.0</code>，二者均都无效。</p><h4 id="inderict"><a href="#inderict" class="headerlink" title="inderict"></a>inderict</h4><p>间接引用，比如A引用了B，B引用了C，但是B项目没有采用go moudle管理方式或者缺失go.mod或者go.mod中缺失C，那么在A的go.mod中就会添加C并且后面跟着<br>&#x2F;&#x2F; inderict</p><h4 id="go-get与go-install"><a href="#go-get与go-install" class="headerlink" title="go get与go install"></a>go get与go install</h4><p>go get 和 go install 是 Go 语言中的两个常用命令，它们用于获取和安装依赖包或将代码编译为可执行文件。它们的区别如下：</p><p>1、go get：</p><p>go get 用于获取、更新和安装远程依赖包。它会自动从远程代码库（如 GitHub、GitLab）下载依赖包，并将其安装到 GOPATH 或 GOMOD 目录中。</p><p>当您执行 go get 命令时，它会下载指定的包及其依赖项，并将其放置在正确的目录结构中，以供项目引用。</p><p>通常，go get 会自动安装依赖项，无需手动执行 go install。</p><p>2、go install：</p><p>go install 用于编译并安装 Go 语言的可执行程序。它将 Go 代码编译成二进制文件，并将其安装到 GOPATH 或 GOMOD 的 bin 目录中，以供后续执行。</p><p>当您执行 go install 命令时，它会在当前包的目录中执行编译过程，并将生成的可执行文件放置在 bin 目录中。</p><p>通过 go install 安装的可执行文件可以通过命令行直接运行，无需指定文件路径。</p><p>golang的1.16版本之后，go install可以在模块感知的模式下运行，可忽略当前目录或上层目录的 go.mod 文件。这对于在不影响主模块依赖的情况下（不会修改go.mod文件），安装二进制很方便；</p><ul><li>在将来，go install 被设计为“用于构建和安装二进制文件”， go get 则被设计为 “用于编辑 go.mod 变更依赖”，并且使用时，应该与 <code>-d</code> 参数共用，在将来版本中 <code>-d</code> 可能会默认启用；</li><li>非常的简单直观。需要注意的是 go install package@version是从 1.16 开始增加的，无论你当前是否在一个模块下，此命令都会在 <code>$GOPATH/bin</code> 下安装指定版本的工具。</li></ul><p>go get 将二进制安装相关的功能都转移到了 <code>go install</code>, 仅作为用于编辑 <code>go.mod</code> 文件的命令存在。在后续版本（计划是 Go 1.17）中删掉 <code>go get</code> 安装二进制的功能，接下来 <code>go get</code> 的行为就等同于我们现在执行 <code>go get -d</code> 命令了，仅需下载源码，并将依赖添加至 <code>go.mod</code> 即可。</p><p>在 Go 1.16 中，另一个行为变更是 <code>go build</code> 和 <code>go test</code> 不会自动编辑 <code>go.mod</code> 了，基于以上信息，Go 1.16 中将进行如下处理：</p><ul><li><p>通过在代码中修改 import 语句，来修改 <code>go.mod</code>：</p><ul><li><code>go get</code> 可用于添加新模块；</li><li><code>go mod tidy</code> 删除掉无用的模块；</li></ul></li><li><p>将未导入的模块写入 <code>go.mod</code>:</p><ul><li><code>go get &lt;package&gt;@&lt;version&gt;</code>;</li><li><code>go mod tidy</code> 也可以；</li><li>手动编辑；</li></ul></li></ul><h3 id="go-work"><a href="#go-work" class="headerlink" title="go work"></a>go work</h3><p>go work机制是1.18版本推出的，是go moudle的最后一块拼图</p><p>go work没出来之前的问题：</p><ul><li>当go.mod中引用的moudle未在github发布，那么go mod tidy时候会报错（多moudle开发的时候经常会遇到这个问题）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;总结一下go moudle相关内容&lt;/p&gt;
&lt;p&gt;golang的包管理经历了GOPATH、go vendor、go moudle三个阶段&lt;/p&gt;
&lt;h3 id=&quot;GOPATH机制&quot;&gt;&lt;a href=&quot;#GOPATH机制&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    <category term="golang" scheme="http://example.com/categories/golang/"/>
    
    
    <category term="golang" scheme="http://example.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>go包管理详解</title>
    <link href="http://example.com/2024/09/05/golang/go%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2024/09/05/golang/go%E5%8C%85%E7%AE%A1%E7%90%86/</id>
    <published>2024-09-05T01:46:45.408Z</published>
    <updated>2025-02-21T09:51:11.311Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下golang包管理内容</p><h2 id="go-mod"><a href="#go-mod" class="headerlink" title="go mod"></a>go mod</h2><h3 id="go-get与go-install"><a href="#go-get与go-install" class="headerlink" title="go get与go install"></a>go get与go install</h3><p>go get 和 go install 是 Go 语言中的两个常用命令，它们用于获取和安装依赖包或将代码编译为可执行文件。它们的区别如下：</p><p>1、go get：</p><p>go get 用于获取、更新和安装远程依赖包。它会自动从远程代码库（如 GitHub、GitLab）下载依赖包，并将其安装到 GOPATH 或 GOMOD 目录中。</p><p>当您执行 go get 命令时，它会下载指定的包及其依赖项，并将其放置在正确的目录结构中，以供项目引用。</p><p>通常，go get 会自动安装依赖项，无需手动执行 go install。</p><p>2、go install：</p><p>go install 用于编译并安装 Go 语言的可执行程序。它将 Go 代码编译成二进制文件，并将其安装到 GOPATH 或 GOMOD 的 bin 目录中，以供后续执行。</p><p>当您执行 go install 命令时，它会在当前包的目录中执行编译过程，并将生成的可执行文件放置在 bin 目录中。</p><p>通过 go install 安装的可执行文件可以通过命令行直接运行，无需指定文件路径。</p><p>golang的1.16版本之后，go install可以在模块感知的模式下运行，可忽略当前目录或上层目录的 go.mod 文件。这对于在不影响主模块依赖的情况下（不会修改go.mod文件），安装二进制很方便；</p><ul><li>在将来，go install 被设计为“用于构建和安装二进制文件”， go get 则被设计为 “用于编辑 go.mod 变更依赖”，并且使用时，应该与 <code>-d</code> 参数共用，在将来版本中 <code>-d</code> 可能会默认启用；</li><li>非常的简单直观。需要注意的是 go install &lt;package@<version> 是从 1.16 开始增加的，无论你当前是否在一个模块下，此命令都会在 <code>$GOPATH/bin</code> 下安装指定版本的工具。</li></ul><p>go get 将二进制安装相关的功能都转移到了 <code>go install</code>, 仅作为用于编辑 <code>go.mod</code> 文件的命令存在。在后续版本（计划是 Go 1.17）中删掉 <code>go get</code> 安装二进制的功能，接下来 <code>go get</code> 的行为就等同于我们现在执行 <code>go get -d</code> 命令了，仅需下载源码，并将依赖添加至 <code>go.mod</code> 即可。</p><p>在 Go 1.16 中，另一个行为变更是 <code>go build</code> 和 <code>go test</code> 不会自动编辑 <code>go.mod</code> 了，基于以上信息，Go 1.16 中将进行如下处理：</p><ul><li><p>通过在代码中修改 import 语句，来修改 <code>go.mod</code>：</p><ul><li><code>go get</code> 可用于添加新模块；</li><li><code>go mod tidy</code> 删除掉无用的模块；</li></ul></li><li><p>将未导入的模块写入 <code>go.mod</code>:</p><ul><li><code>go get &lt;package&gt;[@&lt;version&gt;]</code>;</li><li><code>go mod tidy</code> 也可以；</li><li>手动编辑；</li></ul></li></ul><h3 id="go-work"><a href="#go-work" class="headerlink" title="go work"></a>go work</h3><p>go work机制是1.18版本推出的，是go moudle的最后一块拼图</p><p>go work没出来之前的问题：</p><ul><li>当go.mod中引用的moudle未在github发布，那么go mod tidy时候会报错（多moudle开发的时候经常会遇到这个问题）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;总结一下golang包管理内容&lt;/p&gt;
&lt;h2 id=&quot;go-mod&quot;&gt;&lt;a href=&quot;#go-mod&quot; class=&quot;headerlink&quot; title=&quot;go mod&quot;&gt;&lt;/a&gt;go mod&lt;/h2&gt;&lt;h3 id=&quot;go-get与go-install&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="golang" scheme="http://example.com/categories/golang/"/>
    
    
    <category term="golang" scheme="http://example.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>goframe实践-2 ｜web开发</title>
    <link href="http://example.com/2024/08/25/goframe%E6%A1%86%E6%9E%B6/goframe%E5%AE%9E%E8%B7%B5-2%20%EF%BD%9Cweb%E5%BC%80%E5%8F%91/"/>
    <id>http://example.com/2024/08/25/goframe%E6%A1%86%E6%9E%B6/goframe%E5%AE%9E%E8%B7%B5-2%20%EF%BD%9Cweb%E5%BC%80%E5%8F%91/</id>
    <published>2024-08-25T09:17:40.002Z</published>
    <updated>2024-08-25T09:22:46.005Z</updated>
    
    
    
    
    <category term="goframe框架" scheme="http://example.com/categories/goframe%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
</feed>
