<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>goframe实践-1｜架构与目录</title>
    <url>/2024/08/23/goframe%E6%A1%86%E6%9E%B6/goframe%E5%AE%9E%E8%B7%B5-1%EF%BD%9C%E6%9E%B6%E6%9E%84%E4%B8%8E%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h2 id="工程目录"><a href="#工程目录" class="headerlink" title="工程目录"></a>工程目录</h2><blockquote>
<p><a class="link"   href="https://goframe.org/pages/viewpage.action?pageId=30740166" >https://goframe.org/pages/viewpage.action?pageId=30740166<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p>基本的工程目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/</span><br><span class="line">├── api</span><br><span class="line">├── hack</span><br><span class="line">├── internal</span><br><span class="line">│   ├── cmd</span><br><span class="line">│   ├── consts</span><br><span class="line">│   ├── controller</span><br><span class="line">│   ├── dao</span><br><span class="line">│   ├── logic</span><br><span class="line">│   ├── model</span><br><span class="line">│   |   ├── do</span><br><span class="line">│   │   └── entity</span><br><span class="line">│   └── service</span><br><span class="line">├── manifest</span><br><span class="line">├── resource</span><br><span class="line">├── utility</span><br><span class="line">├── go.mod</span><br><span class="line">└── main.go </span><br></pre></td></tr></table></figure>
<p>一个大体的目录结构如上，当然可以根据需要增减<br>goframe官方提供的一个示例项目focus-single目录如下：<br><img   src="https://raw.githubusercontent.com/miller-star/picture/master/20240909102833.png"  alt="image.png"></p>
<p>整体流程<br><img   src="https://goframe.org/download/attachments/30740166/image2022-6-22_16-2-37.png?version=1&modificationDate=1655884751621&api=v2" ></p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>这里着重讲一下model目录，数据结构管理模块，管理数据实体对象，以及输入与输出数据结构定义。<br><img   src="https://goframe.org/download/attachments/30740166/image2022-1-18_0-47-31.png?version=1&modificationDate=1642437918159&api=v2" ></p>
]]></content>
      <categories>
        <category>goframe框架</category>
      </categories>
      <tags>
        <tag>goframe</tag>
      </tags>
  </entry>
  <entry>
    <title>goframe实践-2 ｜web开发</title>
    <url>/2024/08/25/goframe%E6%A1%86%E6%9E%B6/goframe%E5%AE%9E%E8%B7%B5-2%20%EF%BD%9Cweb%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>goframe框架</category>
      </categories>
  </entry>
  <entry>
    <title>golang-gin框架实践(一)|请求与Context</title>
    <url>/2024/07/09/gin/golang-gin%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>gin是一个简洁高效的web框架，自然而然就肯定会有与请求信息相关的处理逻辑。本文从这个角度来看下gin框架是怎么做的。</p>
<span id="more"></span>

<p>目录如下：</p>
<ul>
<li>RestAPI</li>
<li>Gin中处理请求的接口</li>
</ul>
<h2 id="Restful-API"><a href="#Restful-API" class="headerlink" title="Restful API"></a>Restful API</h2><blockquote>
<p><a class="link"   href="https://restfulapi.cn/" >https://restfulapi.cn/<i class="fas fa-external-link-alt"></i></a>  ！！！！必看</p>
<p><a class="link"   href="https://aws.amazon.com/cn/what-is/restful-api/" >https://aws.amazon.com/cn/what-is/restful-api/<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://cloud.tencent.com/developer/article/2360813" >https://cloud.tencent.com/developer/article/2360813<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p>表征状态传输 (REST) 是一种软件架构，决定了 API 的工作条件。REST 最初作为管理复杂网络（例如互联网）上的通信的指南而建立。您可以使用基于 REST 的架构为高性能和可靠的大规模通信提供支持。您可以轻松应用和修改此种架构，为任何 API 系统带来可见性和跨平台可能性。</p>
<h3 id="Restful-API风格"><a href="#Restful-API风格" class="headerlink" title="Restful API风格"></a>Restful API风格</h3><p>传统url接口与Restful风格接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端请求						传统url接口				REST ful风格接口</span><br><span class="line">查询所有用户					/user/findAll				GET /users</span><br><span class="line">查询编号为1的用户		 	/user/findById?id=1				 GET /user/1         </span><br><span class="line">新增一个用户				   /user/save				 POST /user</span><br><span class="line">修改编号为1的用户		    /user/update				PUT /user/1</span><br><span class="line">删除编号为1的用户		    /user/delete?id=1				DELETE /user/1</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">HTTP Method</th>
<th align="left">资源操作</th>
<th align="left">CRUD操作</th>
<th align="left">安全性</th>
<th align="left">幂等性</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">GET</td>
<td align="left">SELECT</td>
<td align="left">SELECT</td>
<td align="left">安全</td>
<td align="left">幂等</td>
<td align="left">读操作安全，查询一次多次结果一致</td>
</tr>
<tr>
<td align="left">POST</td>
<td align="left">INSERT</td>
<td align="left">CREATE</td>
<td align="left">非安全</td>
<td align="left">非幂等</td>
<td align="left">写操作非安全，每多插入一次都会出现新结果</td>
</tr>
<tr>
<td align="left">PUT</td>
<td align="left">UPDATE</td>
<td align="left">UPDATE</td>
<td align="left">非安全</td>
<td align="left">幂等</td>
<td align="left">写操作非安全，一次和多次更新结果一致</td>
</tr>
<tr>
<td align="left">DELETE</td>
<td align="left">DELETE</td>
<td align="left">DELETE</td>
<td align="left">非安全</td>
<td align="left">幂等</td>
<td align="left">写操作非安全，一次和多次删除结果一致</td>
</tr>
</tbody></table>
<p>Restful API设计遵循以下几个规范：</p>
<ul>
<li>使用HTTP Method动词来表达操作</li>
<li>使用名词来表示资源</li>
<li>使用URL来定位资源</li>
<li>使用查询参数来过滤和分页</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取前10个用户：		GET /users?limit=10</span><br><span class="line">获取第二页的用户：		GET /users?page=2&amp;limit=10</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用HTTP状态码来表示请求结果</p>
</li>
<li><p>使用json或xml来表示数据</p>
</li>
<li><p>使用版本号来管理API</p>
</li>
<li><p>提供清晰的错误信息</p>
</li>
<li><p>使用标准的HTTP头部</p>
<p>使用HTTP头部中的<strong>Accept</strong>和<strong>Content-Type</strong>字段进行内容协商，以确定客户端期望的表示形式和服务器返回的表示形式。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">接受JSON格式的响应：Accept: application/json</span><br><span class="line">发送JSON格式的请求体：Content-Type: application/json</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Gin中请求的流转"><a href="#Gin中请求的流转" class="headerlink" title="Gin中请求的流转"></a>Gin中请求的流转</h2><blockquote>
<p><a class="link"   href="https://www.cnblogs.com/yuanwebpage/p/16818047.html" >https://www.cnblogs.com/yuanwebpage/p/16818047.html<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p>gin框架的底层采用golang原生网络库net&#x2F;http，遵循one connection per goroutine的原则。因此在讲解gin处理request之前，我们需要看看go的原生网络库net&#x2F;http是怎么处理请求的。</p>
<h3 id="net-http如何处理请求"><a href="#net-http如何处理请求" class="headerlink" title="net&#x2F;http如何处理请求"></a>net&#x2F;http如何处理请求</h3><p>利用net&#x2F;http处理请求的代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(rw http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        io.WriteString(rw, <span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    &#125;) <span class="comment">// 注册路由</span></span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;localhost:8000&quot;</span>, <span class="literal">nil</span>) <span class="comment">// 启动服务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，http.HandleFunc()用于注册路由。所谓路由，就是给定一个URL地址，要找到处理该URL的函数，自然最理想的结构就是map，map的key保存URL地址，value保存处理URL的响应函数(handler)，这样就能根据URL，快速定位函数并执行调用。http.HandleFunc()将这个路由map保存到了默认的服务端实例DefaultServeMux（ServeMux结构体对象）上，ServeMux的结构如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu    sync.RWMutex  <span class="comment">// 读写锁，用于并发访问路由map时加锁保护</span></span><br><span class="line">    m     <span class="keyword">map</span>[<span class="type">string</span>]muxEntry <span class="comment">// 保存路由的map</span></span><br><span class="line">    es    []muxEntry <span class="comment">// slice of entries sorted from longest to shortest. 基于路径保存的handler列表</span></span><br><span class="line">    hosts <span class="type">bool</span>       <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">    h       Handler <span class="comment">// Handler是go的标准网络处理函数，任何实现了ServeHTTP(ResponseWriter, *Request)的函数都可以作为Handler</span></span><br><span class="line">    pattern <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>http.HandleFunc()具体功能就是将用户定义的Handler函数保存到DefaultServeMux.m中，原理较为简单，在此不再赘述。</p>
<p><img   src="https://raw.githubusercontent.com/miller-star/picture/master/1951229-20221023100944302-1862362530.png" ></p>
<h2 id="Gin中处理请求的接口"><a href="#Gin中处理请求的接口" class="headerlink" title="Gin中处理请求的接口"></a>Gin中处理请求的接口</h2><p>主要通过context结构体中的相关方法来处理请求</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Context is the most important part of gin. It allows us to pass variables between middleware,</span></span><br><span class="line"><span class="comment">// manage the flow, validate the JSON of a request and render a JSON response for example.</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">	writermem responseWriter</span><br><span class="line">	Request   *http.Request</span><br><span class="line">	Writer    ResponseWriter</span><br><span class="line"></span><br><span class="line">	Params   Params</span><br><span class="line">	handlers HandlersChain</span><br><span class="line">	index    <span class="type">int8</span></span><br><span class="line"></span><br><span class="line">	engine *Engine</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Keys is a key/value pair exclusively for the context of each request.</span></span><br><span class="line">	Keys <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Errors is a list of errors attached to all the handlers/middlewares who used this context.</span></span><br><span class="line">	Errors errorMsgs</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Accepted defines a list of manually accepted formats for content negotiation.</span></span><br><span class="line">	Accepted []<span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>context类型的全部方法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/************************************/</span></span><br><span class="line"><span class="comment">/************ INPUT DATA ************/</span></span><br><span class="line"><span class="comment">/************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Param returns the value of the URL param.</span></span><br><span class="line"><span class="comment">// It is a shortcut for c.Params.ByName(key)</span></span><br><span class="line"><span class="comment">//     router.GET(&quot;/user/:id&quot;, func(c *gin.Context) &#123;</span></span><br><span class="line"><span class="comment">//         // a GET request to /user/john</span></span><br><span class="line"><span class="comment">//         id := c.Param(&quot;id&quot;) // id == &quot;john&quot;</span></span><br><span class="line"><span class="comment">//     &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Param(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.Params.ByName(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Query returns the keyed url query value if it exists,</span></span><br><span class="line"><span class="comment">// otherwise it returns an empty string `(&quot;&quot;)`.</span></span><br><span class="line"><span class="comment">// It is shortcut for `c.Request.URL.Query().Get(key)`</span></span><br><span class="line"><span class="comment">//     GET /path?id=1234&amp;name=Manu&amp;value=</span></span><br><span class="line"><span class="comment">// 	   c.Query(&quot;id&quot;) == &quot;1234&quot;</span></span><br><span class="line"><span class="comment">// 	   c.Query(&quot;name&quot;) == &quot;Manu&quot;</span></span><br><span class="line"><span class="comment">// 	   c.Query(&quot;value&quot;) == &quot;&quot;</span></span><br><span class="line"><span class="comment">// 	   c.Query(&quot;wtf&quot;) == &quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Query(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">	value, _ := c.GetQuery(key)</span><br><span class="line">	<span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultQuery returns the keyed url query value if it exists,</span></span><br><span class="line"><span class="comment">// otherwise it returns the specified defaultValue string.</span></span><br><span class="line"><span class="comment">// See: Query() and GetQuery() for further information.</span></span><br><span class="line"><span class="comment">//     GET /?name=Manu&amp;lastname=</span></span><br><span class="line"><span class="comment">//     c.DefaultQuery(&quot;name&quot;, &quot;unknown&quot;) == &quot;Manu&quot;</span></span><br><span class="line"><span class="comment">//     c.DefaultQuery(&quot;id&quot;, &quot;none&quot;) == &quot;none&quot;</span></span><br><span class="line"><span class="comment">//     c.DefaultQuery(&quot;lastname&quot;, &quot;none&quot;) == &quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> DefaultQuery(key, defaultValue <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> value, ok := c.GetQuery(key); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> value</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> defaultValue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetQuery is like Query(), it returns the keyed url query value</span></span><br><span class="line"><span class="comment">// if it exists `(value, true)` (even when the value is an empty string),</span></span><br><span class="line"><span class="comment">// otherwise it returns `(&quot;&quot;, false)`.</span></span><br><span class="line"><span class="comment">// It is shortcut for `c.Request.URL.Query().Get(key)`</span></span><br><span class="line"><span class="comment">//     GET /?name=Manu&amp;lastname=</span></span><br><span class="line"><span class="comment">//     (&quot;Manu&quot;, true) == c.GetQuery(&quot;name&quot;)</span></span><br><span class="line"><span class="comment">//     (&quot;&quot;, false) == c.GetQuery(&quot;id&quot;)</span></span><br><span class="line"><span class="comment">//     (&quot;&quot;, true) == c.GetQuery(&quot;lastname&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> GetQuery(key <span class="type">string</span>) (<span class="type">string</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> values, ok := c.GetQueryArray(key); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> values[<span class="number">0</span>], ok</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// QueryArray returns a slice of strings for a given query key.</span></span><br><span class="line"><span class="comment">// The length of the slice depends on the number of params with the given key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> QueryArray(key <span class="type">string</span>) []<span class="type">string</span> &#123;</span><br><span class="line">	values, _ := c.GetQueryArray(key)</span><br><span class="line">	<span class="keyword">return</span> values</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetQueryArray returns a slice of strings for a given query key, plus</span></span><br><span class="line"><span class="comment">// a boolean value whether at least one value exists for the given key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> GetQueryArray(key <span class="type">string</span>) ([]<span class="type">string</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> values, ok := c.Request.URL.Query()[key]; ok &amp;&amp; <span class="built_in">len</span>(values) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> values, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> []<span class="type">string</span>&#123;&#125;, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// QueryMap returns a map for a given query key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> QueryMap(key <span class="type">string</span>) <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> &#123;</span><br><span class="line">	dicts, _ := c.GetQueryMap(key)</span><br><span class="line">	<span class="keyword">return</span> dicts</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetQueryMap returns a map for a given query key, plus a boolean value</span></span><br><span class="line"><span class="comment">// whether at least one value exists for the given key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> GetQueryMap(key <span class="type">string</span>) (<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> c.get(c.Request.URL.Query(), key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostForm returns the specified key from a POST urlencoded form or multipart form</span></span><br><span class="line"><span class="comment">// when it exists, otherwise it returns an empty string `(&quot;&quot;)`.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> PostForm(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">	value, _ := c.GetPostForm(key)</span><br><span class="line">	<span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultPostForm returns the specified key from a POST urlencoded form or multipart form</span></span><br><span class="line"><span class="comment">// when it exists, otherwise it returns the specified defaultValue string.</span></span><br><span class="line"><span class="comment">// See: PostForm() and GetPostForm() for further information.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> DefaultPostForm(key, defaultValue <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> value, ok := c.GetPostForm(key); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> value</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> defaultValue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetPostForm is like PostForm(key). It returns the specified key from a POST urlencoded</span></span><br><span class="line"><span class="comment">// form or multipart form when it exists `(value, true)` (even when the value is an empty string),</span></span><br><span class="line"><span class="comment">// otherwise it returns (&quot;&quot;, false).</span></span><br><span class="line"><span class="comment">// For example, during a PATCH request to update the user&#x27;s email:</span></span><br><span class="line"><span class="comment">//     email=mail@example.com  --&gt;  (&quot;mail@example.com&quot;, true) := GetPostForm(&quot;email&quot;) // set email to &quot;mail@example.com&quot;</span></span><br><span class="line"><span class="comment">// 	   email=                  --&gt;  (&quot;&quot;, true) := GetPostForm(&quot;email&quot;) // set email to &quot;&quot;</span></span><br><span class="line"><span class="comment">//                             --&gt;  (&quot;&quot;, false) := GetPostForm(&quot;email&quot;) // do nothing with email</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> GetPostForm(key <span class="type">string</span>) (<span class="type">string</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> values, ok := c.GetPostFormArray(key); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> values[<span class="number">0</span>], ok</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostFormArray returns a slice of strings for a given form key.</span></span><br><span class="line"><span class="comment">// The length of the slice depends on the number of params with the given key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> PostFormArray(key <span class="type">string</span>) []<span class="type">string</span> &#123;</span><br><span class="line">	values, _ := c.GetPostFormArray(key)</span><br><span class="line">	<span class="keyword">return</span> values</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetPostFormArray returns a slice of strings for a given form key, plus</span></span><br><span class="line"><span class="comment">// a boolean value whether at least one value exists for the given key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> GetPostFormArray(key <span class="type">string</span>) ([]<span class="type">string</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">	req := c.Request</span><br><span class="line">	<span class="keyword">if</span> err := req.ParseMultipartForm(c.engine.MaxMultipartMemory); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != http.ErrNotMultipart &#123;</span><br><span class="line">			debugPrint(<span class="string">&quot;error on parse multipart form array: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> values := req.PostForm[key]; <span class="built_in">len</span>(values) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> values, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> []<span class="type">string</span>&#123;&#125;, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostFormMap returns a map for a given form key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> PostFormMap(key <span class="type">string</span>) <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> &#123;</span><br><span class="line">	dicts, _ := c.GetPostFormMap(key)</span><br><span class="line">	<span class="keyword">return</span> dicts</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetPostFormMap returns a map for a given form key, plus a boolean value</span></span><br><span class="line"><span class="comment">// whether at least one value exists for the given key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> GetPostFormMap(key <span class="type">string</span>) (<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">	req := c.Request</span><br><span class="line">	<span class="keyword">if</span> err := req.ParseMultipartForm(c.engine.MaxMultipartMemory); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != http.ErrNotMultipart &#123;</span><br><span class="line">			debugPrint(<span class="string">&quot;error on parse multipart form map: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.get(req.PostForm, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get is an internal method and returns a map which satisfy conditions.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> get(m <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>, key <span class="type">string</span>) (<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">	dicts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">	exist := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		<span class="keyword">if</span> i := strings.IndexByte(k, <span class="string">&#x27;[&#x27;</span>); i &gt;= <span class="number">1</span> &amp;&amp; k[<span class="number">0</span>:i] == key &#123;</span><br><span class="line">			<span class="keyword">if</span> j := strings.IndexByte(k[i+<span class="number">1</span>:], <span class="string">&#x27;]&#x27;</span>); j &gt;= <span class="number">1</span> &#123;</span><br><span class="line">				exist = <span class="literal">true</span></span><br><span class="line">				dicts[k[i+<span class="number">1</span>:][:j]] = v[<span class="number">0</span>]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dicts, exist</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FormFile returns the first file for the provided form key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> FormFile(name <span class="type">string</span>) (*multipart.FileHeader, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> c.Request.MultipartForm == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := c.Request.ParseMultipartForm(c.engine.MaxMultipartMemory); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	_, fh, err := c.Request.FormFile(name)</span><br><span class="line">	<span class="keyword">return</span> fh, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MultipartForm is the parsed multipart form, including file uploads.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> MultipartForm() (*multipart.Form, <span class="type">error</span>) &#123;</span><br><span class="line">	err := c.Request.ParseMultipartForm(c.engine.MaxMultipartMemory)</span><br><span class="line">	<span class="keyword">return</span> c.Request.MultipartForm, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SaveUploadedFile uploads the form file to specific dst.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> SaveUploadedFile(file *multipart.FileHeader, dst <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	src, err := file.Open()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> src.Close()</span><br><span class="line"></span><br><span class="line">	out, err := os.Create(dst)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> out.Close()</span><br><span class="line"></span><br><span class="line">	_, err = io.Copy(out, src)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bind checks the Content-Type to select a binding engine automatically,</span></span><br><span class="line"><span class="comment">// Depending the &quot;Content-Type&quot; header different bindings are used:</span></span><br><span class="line"><span class="comment">//     &quot;application/json&quot; --&gt; JSON binding</span></span><br><span class="line"><span class="comment">//     &quot;application/xml&quot;  --&gt; XML binding</span></span><br><span class="line"><span class="comment">// otherwise --&gt; returns an error.</span></span><br><span class="line"><span class="comment">// It parses the request&#x27;s body as JSON if Content-Type == &quot;application/json&quot; using JSON or XML as a JSON input.</span></span><br><span class="line"><span class="comment">// It decodes the json payload into the struct specified as a pointer.</span></span><br><span class="line"><span class="comment">// It writes a 400 error and sets Content-Type header &quot;text/plain&quot; in the response if input is not valid.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Bind(obj <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	b := binding.Default(c.Request.Method, c.ContentType())</span><br><span class="line">	<span class="keyword">return</span> c.MustBindWith(obj, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BindJSON is a shortcut for c.MustBindWith(obj, binding.JSON).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> BindJSON(obj <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.MustBindWith(obj, binding.JSON)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BindXML is a shortcut for c.MustBindWith(obj, binding.BindXML).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> BindXML(obj <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.MustBindWith(obj, binding.XML)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BindQuery is a shortcut for c.MustBindWith(obj, binding.Query).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> BindQuery(obj <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.MustBindWith(obj, binding.Query)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BindYAML is a shortcut for c.MustBindWith(obj, binding.YAML).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> BindYAML(obj <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.MustBindWith(obj, binding.YAML)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BindUri binds the passed struct pointer using binding.Uri.</span></span><br><span class="line"><span class="comment">// It will abort the request with HTTP 400 if any error occurs.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> BindUri(obj <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := c.ShouldBindUri(obj); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.AbortWithError(http.StatusBadRequest, err).SetType(ErrorTypeBind) <span class="comment">// nolint: errcheck</span></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MustBindWith binds the passed struct pointer using the specified binding engine.</span></span><br><span class="line"><span class="comment">// It will abort the request with HTTP 400 if any error occurs.</span></span><br><span class="line"><span class="comment">// See the binding package.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> MustBindWith(obj <span class="keyword">interface</span>&#123;&#125;, b binding.Binding) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := c.ShouldBindWith(obj, b); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.AbortWithError(http.StatusBadRequest, err).SetType(ErrorTypeBind) <span class="comment">// nolint: errcheck</span></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ShouldBind checks the Content-Type to select a binding engine automatically,</span></span><br><span class="line"><span class="comment">// Depending the &quot;Content-Type&quot; header different bindings are used:</span></span><br><span class="line"><span class="comment">//     &quot;application/json&quot; --&gt; JSON binding</span></span><br><span class="line"><span class="comment">//     &quot;application/xml&quot;  --&gt; XML binding</span></span><br><span class="line"><span class="comment">// otherwise --&gt; returns an error</span></span><br><span class="line"><span class="comment">// It parses the request&#x27;s body as JSON if Content-Type == &quot;application/json&quot; using JSON or XML as a JSON input.</span></span><br><span class="line"><span class="comment">// It decodes the json payload into the struct specified as a pointer.</span></span><br><span class="line"><span class="comment">// Like c.Bind() but this method does not set the response status code to 400 and abort if the json is not valid.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> ShouldBind(obj <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	b := binding.Default(c.Request.Method, c.ContentType())</span><br><span class="line">	<span class="keyword">return</span> c.ShouldBindWith(obj, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ShouldBindJSON is a shortcut for c.ShouldBindWith(obj, binding.JSON).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> ShouldBindJSON(obj <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.ShouldBindWith(obj, binding.JSON)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ShouldBindXML is a shortcut for c.ShouldBindWith(obj, binding.XML).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> ShouldBindXML(obj <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.ShouldBindWith(obj, binding.XML)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ShouldBindQuery is a shortcut for c.ShouldBindWith(obj, binding.Query).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> ShouldBindQuery(obj <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.ShouldBindWith(obj, binding.Query)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ShouldBindYAML is a shortcut for c.ShouldBindWith(obj, binding.YAML).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> ShouldBindYAML(obj <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.ShouldBindWith(obj, binding.YAML)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ShouldBindUri binds the passed struct pointer using the specified binding engine.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> ShouldBindUri(obj <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> c.Params &#123;</span><br><span class="line">		m[v.Key] = []<span class="type">string</span>&#123;v.Value&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> binding.Uri.BindUri(m, obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ShouldBindWith binds the passed struct pointer using the specified binding engine.</span></span><br><span class="line"><span class="comment">// See the binding package.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> ShouldBindWith(obj <span class="keyword">interface</span>&#123;&#125;, b binding.Binding) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> b.Bind(c.Request, obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ShouldBindBodyWith is similar with ShouldBindWith, but it stores the request</span></span><br><span class="line"><span class="comment">// body into the context, and reuse when it is called again.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> This method reads the body before binding. So you should use</span></span><br><span class="line"><span class="comment">// ShouldBindWith for better performance if you need to call only once.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> ShouldBindBodyWith(obj <span class="keyword">interface</span>&#123;&#125;, bb binding.BindingBody) (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> body []<span class="type">byte</span></span><br><span class="line">	<span class="keyword">if</span> cb, ok := c.Get(BodyBytesKey); ok &#123;</span><br><span class="line">		<span class="keyword">if</span> cbb, ok := cb.([]<span class="type">byte</span>); ok &#123;</span><br><span class="line">			body = cbb</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> body == <span class="literal">nil</span> &#123;</span><br><span class="line">		body, err = ioutil.ReadAll(c.Request.Body)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		c.Set(BodyBytesKey, body)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bb.BindBody(body, obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClientIP implements a best effort algorithm to return the real client IP, it parses</span></span><br><span class="line"><span class="comment">// X-Real-IP and X-Forwarded-For in order to work properly with reverse-proxies such us: nginx or haproxy.</span></span><br><span class="line"><span class="comment">// Use X-Forwarded-For before X-Real-Ip as nginx uses X-Real-Ip with the proxy&#x27;s IP.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> ClientIP() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c.engine.ForwardedByClientIP &#123;</span><br><span class="line">		clientIP := c.requestHeader(<span class="string">&quot;X-Forwarded-For&quot;</span>)</span><br><span class="line">		clientIP = strings.TrimSpace(strings.Split(clientIP, <span class="string">&quot;,&quot;</span>)[<span class="number">0</span>])</span><br><span class="line">		<span class="keyword">if</span> clientIP == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			clientIP = strings.TrimSpace(c.requestHeader(<span class="string">&quot;X-Real-Ip&quot;</span>))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> clientIP != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> clientIP</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.engine.AppEngine &#123;</span><br><span class="line">		<span class="keyword">if</span> addr := c.requestHeader(<span class="string">&quot;X-Appengine-Remote-Addr&quot;</span>); addr != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> addr</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ip, _, err := net.SplitHostPort(strings.TrimSpace(c.Request.RemoteAddr)); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ip</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ContentType returns the Content-Type header of the request.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> ContentType() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> filterFlags(c.requestHeader(<span class="string">&quot;Content-Type&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IsWebsocket returns true if the request headers indicate that a websocket</span></span><br><span class="line"><span class="comment">// handshake is being initiated by the client.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> IsWebsocket() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> strings.Contains(strings.ToLower(c.requestHeader(<span class="string">&quot;Connection&quot;</span>)), <span class="string">&quot;upgrade&quot;</span>) &amp;&amp;</span><br><span class="line">		strings.ToLower(c.requestHeader(<span class="string">&quot;Upgrade&quot;</span>)) == <span class="string">&quot;websocket&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> requestHeader(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.Request.Header.Get(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>gin</category>
      </categories>
      <tags>
        <tag>Gin</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes学习</title>
    <url>/2024/04/09/kubernetes/kubernetes%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="了解架构"><a href="#了解架构" class="headerlink" title="了解架构"></a>了解架构</h2><ul>
<li><p>控制平面</p>
<ul>
<li>etcd分布式持久化存储</li>
<li>API Server</li>
<li>controller manager</li>
<li>调度器</li>
</ul>
</li>
<li><p>工作节点</p>
<ul>
<li>kubelet</li>
<li>kubelet服务代理</li>
<li>容器运行时（如docker、rkt）</li>
</ul>
</li>
<li><p>附加组件</p>
<ul>
<li>kubernetes DNS服务器</li>
<li>仪表板</li>
<li>Ingress控制器</li>
<li>Heapster（容器集群监控）</li>
<li>CNI插件</li>
</ul>
</li>
</ul>
<img     src="https://raw.githubusercontent.com/miller-star/picture/master/20240410102847.png"   style="zoom:50%;" >

<p>可以通过</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get componentstatuses</span><br></pre></td></tr></table></figure>

<p>获取各个控制平面组件的健康状态</p>
<h2 id="API服务器的作用"><a href="#API服务器的作用" class="headerlink" title="API服务器的作用"></a>API服务器的作用</h2><h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h3><img     src="https://raw.githubusercontent.com/miller-star/picture/master/20240411145447.png"   style="zoom:50%;">

<p>认证插件：首先， API 服务器需要认证发送请求的客户端。 这是通过配置在 API 服务器上 的一个或多个认证插件来实现的。 API 服务器会轮流调用这些插件， 直到有一个能 确认是谁发送了该请求。 这是通过检查HTTP请求实现的。</p>
<p>授权插件：除了认证插件， API 服务器还可以配置使用一个或多个授权插件。 它们的作用 是决定认证的用户是否可以对请求资源执行请求操作。 例如， 当创建 pod 时， API 服务器会轮询所有的授权插件， 来确认该用户是否可以在请求命名空间创建 pod。 一旦插件确认了用户可以执行该操作， API 服务器会继续下一步操作。</p>
<p>准入插件：如果请求尝试创建、 修改或者删除一个资源，请求需要经过准入控制插件的验证。（注意：如果仅是读取资源，不会经过准入插件）</p>
<p>请求通过了所有的准入控制插件后， API 服务器会验证存储到 etcd 的对象， 然 后返回一个响应给客户端。</p>
<h3 id="通知客户端资源变更"><a href="#通知客户端资源变更" class="headerlink" title="通知客户端资源变更"></a>通知客户端资源变更</h3><p>API服务器的作用是启动控制器以及其他组件来监控已经部署资源的变更。</p>
<h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><h2 id="控制器管理器中运行的控制器"><a href="#控制器管理器中运行的控制器" class="headerlink" title="控制器管理器中运行的控制器"></a>控制器管理器中运行的控制器</h2><p>由于使用监听机制并不保证控制器不会漏掉时间， 所以 仍然需要定期执行重列举操作来确保不会丢掉什么。</p>
<h2 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h2><p>未完待续。。。。</p>
]]></content>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>beego简单介绍</title>
    <url>/2024/06/14/%E9%9A%8F%E7%AC%94/beego%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="简单安装与入门"><a href="#简单安装与入门" class="headerlink" title="简单安装与入门"></a>简单安装与入门</h2><h3 id="安装命令行工具bee"><a href="#安装命令行工具bee" class="headerlink" title="安装命令行工具bee"></a>安装命令行工具bee</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go install github.com/beego/bee/v2@latest</span><br></pre></td></tr></table></figure>

<h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bee new beego-Admin</span><br></pre></td></tr></table></figure>

<img     src="https://raw.githubusercontent.com/miller-star/picture/master/20240614100255.png"   style="zoom:50%;" >

<p>目录结构如上图所示，是一个典型的MVC架构，M（models 目录）、V（views 目录）和 C（controllers 目录）的结构， <code>main.go</code> 是入口文件。</p>
<h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bee run</span><br></pre></td></tr></table></figure>

<img     src="https://raw.githubusercontent.com/miller-star/picture/master/20240614100629.png"   style="zoom:50%;" >

<p>这样，一个简单的demo就运行起来了</p>
<img     src="https://raw.githubusercontent.com/miller-star/picture/master/20240614100843.png"   style="zoom:50%;" >

<h2 id="框架解析"><a href="#框架解析" class="headerlink" title="框架解析"></a>框架解析</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><img     src="https://raw.githubusercontent.com/beego/beedoc/master/zh-CN/images/architecture.png"   style="zoom:75%;" >

<p>beego 是基于八大独立的模块构建的，是一个高度解耦的框架。当初设计 beego 的时候就是考虑功能模块化，用户即使不使用 beego 的 HTTP 逻辑，也依旧可以使用这些独立模块。</p>
<h3 id="路由设置"><a href="#路由设置" class="headerlink" title="路由设置"></a>路由设置</h3><p><img   src="https://raw.githubusercontent.com/beego/beedoc/master/zh-CN/images/init.png" ></p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>beego官方给出了几个demo项目</p>
<p><a class="link"   href="https://github.com/beego/samples" >https://github.com/beego/samples<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>web beego</tag>
      </tags>
  </entry>
  <entry>
    <title>centos-python基础镜像构建</title>
    <url>/2024/07/18/%E9%9A%8F%E7%AC%94/centos-python%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<blockquote>
<p><a class="link"   href="https://www.cnblogs.com/leeona/p/18282312" >https://www.cnblogs.com/leeona/p/18282312<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p>上述方案解决centos:7基础镜像无法pip的问题</p>
<blockquote>
<p><a class="link"   href="https://www.cnblogs.com/Jimc/p/10218387.html" >https://www.cnblogs.com/Jimc/p/10218387.html<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   href="https://www.cnblogs.com/Jimc/p/10218062.html" >https://www.cnblogs.com/Jimc/p/10218062.html<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p>源码编译安装python3.8</p>
]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>centos9安装mysql服务端记录</title>
    <url>/2024/07/18/%E9%9A%8F%E7%AC%94/centos9%E5%AE%89%E8%A3%85mysql%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>安装的主要流程：<a class="link"   href="https://www.sjkjc.com/posts/install-mysql8-on-centos-stream-9/" >https://www.sjkjc.com/posts/install-mysql8-on-centos-stream-9/<i class="fas fa-external-link-alt"></i></a></p>
<p>之后，远程登录的时候，会报错：</p>
<p>mysql -h ‘安装mysql服务端机器的IP’ -u root</p>
<p>ERROR 1130 (HY000): Host ‘客户端的IP’ is not allowed to connect to this MySQL server这个错误什么原因导致的。</p>
<p>这通常是由于 MySQL 的权限设置导致的。</p>
<p>MySQL 的权限系统允许数据库管理员指定哪些用户可以从哪些主机连接到服务器。在这个案例中，尽管你使用了 <code>root</code> 用户，但可能 <code>root</code> 用户没有从 <code>客户端IP</code> 这个 IP 地址连接到服务器的权限。</p>
<p>在 MySQL 中，<code>GRANT</code> 语句用于分配权限，但是 <code>IDENTIFIED BY</code> 子句用于创建用户或更改用户密码，并不应该在 <code>GRANT</code> 语句中使用。因此，你遇到的错误是因为语法不正确。</p>
<p>你应该首先确保用户 <code>root</code>@<code>客户端IP</code> 存在，如果不存在，你需要先创建这个用户，然后再分配权限。以下是正确的步骤：</p>
<ol>
<li><p>创建用户（如果尚不存在）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE USER &#x27;root&#x27;@&#x27;客户端IP&#x27; IDENTIFIED BY &#x27;WingKin45@&#x27;;</span><br></pre></td></tr></table></figure>


</li>
<li><p>分配权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;客户端IP&#x27; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使权限更改生效</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>按照这些步骤操作后，<code>root</code> 用户应该能够从 IP 地址 <code>客户端IP</code> 连接到 MySQL 服务器，并拥有所有数据库和表的权限。如果你仍然遇到问题，请检查 MySQL 服务器的配置文件（如 <code>my.cnf</code> 或 <code>my.ini</code>），确保没有限制远程连接的设置。</p>
]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>docker命令</title>
    <url>/2024/07/18/%E9%9A%8F%E7%AC%94/docker%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="docker-常用命令"><a href="#docker-常用命令" class="headerlink" title="docker 常用命令"></a>docker 常用命令</h2><blockquote>
<p><a class="link"   href="https://yeasy.gitbook.io/docker_practice/image/commit" >https://yeasy.gitbook.io/docker_practice/image/commit<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p>1.docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker commit \</span><br><span class="line">    --author &quot;Tao Wang &lt;twang2218@gmail.com&gt;&quot; \</span><br><span class="line">    --message &quot;修改了默认网页&quot; \</span><br><span class="line">    webserver \</span><br><span class="line">    nginx:v2</span><br><span class="line">sha256:07e33465974800ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214</span><br></pre></td></tr></table></figure>

<ol start="2">
<li></li>
</ol>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2024/07/16/%E9%9A%8F%E7%AC%94/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p><a class="link"   href="https://blog.csdn.net/justloveyou_/article/details/64127789" >https://blog.csdn.net/justloveyou_/article/details/64127789<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p>golang的单例模式：</p>
<blockquote>
<p><a class="link"   href="https://blog.csdn.net/qq_43035350/article/details/125536474" >https://blog.csdn.net/qq_43035350/article/details/125536474<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>go包管理详解</title>
    <url>/2024/09/05/golang/go%E5%8C%85%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>总结一下golang包管理内容</p>
<h2 id="go-mod"><a href="#go-mod" class="headerlink" title="go mod"></a>go mod</h2><h3 id="go-get与go-install"><a href="#go-get与go-install" class="headerlink" title="go get与go install"></a>go get与go install</h3><p>go get 和 go install 是 Go 语言中的两个常用命令，它们用于获取和安装依赖包或将代码编译为可执行文件。它们的区别如下：</p>
<p>1、go get：</p>
<p>go get 用于获取、更新和安装远程依赖包。它会自动从远程代码库（如 GitHub、GitLab）下载依赖包，并将其安装到 GOPATH 或 GOMOD 目录中。</p>
<p>当您执行 go get 命令时，它会下载指定的包及其依赖项，并将其放置在正确的目录结构中，以供项目引用。</p>
<p>通常，go get 会自动安装依赖项，无需手动执行 go install。</p>
<p>2、go install：</p>
<p>go install 用于编译并安装 Go 语言的可执行程序。它将 Go 代码编译成二进制文件，并将其安装到 GOPATH 或 GOMOD 的 bin 目录中，以供后续执行。</p>
<p>当您执行 go install 命令时，它会在当前包的目录中执行编译过程，并将生成的可执行文件放置在 bin 目录中。</p>
<p>通过 go install 安装的可执行文件可以通过命令行直接运行，无需指定文件路径。</p>
<p>golang的1.16版本之后，go install可以在模块感知的模式下运行，可忽略当前目录或上层目录的 go.mod 文件。这对于在不影响主模块依赖的情况下（不会修改go.mod文件），安装二进制很方便；</p>
<ul>
<li>在将来，go install 被设计为“用于构建和安装二进制文件”， go get 则被设计为 “用于编辑 go.mod 变更依赖”，并且使用时，应该与 <code>-d</code> 参数共用，在将来版本中 <code>-d</code> 可能会默认启用；</li>
<li>非常的简单直观。需要注意的是 go install &lt;package@<version> 是从 1.16 开始增加的，无论你当前是否在一个模块下，此命令都会在 <code>$GOPATH/bin</code> 下安装指定版本的工具。</li>
</ul>
<p>go get 将二进制安装相关的功能都转移到了 <code>go install</code>, 仅作为用于编辑 <code>go.mod</code> 文件的命令存在。在后续版本（计划是 Go 1.17）中删掉 <code>go get</code> 安装二进制的功能，接下来 <code>go get</code> 的行为就等同于我们现在执行 <code>go get -d</code> 命令了，仅需下载源码，并将依赖添加至 <code>go.mod</code> 即可。</p>
<p>在 Go 1.16 中，另一个行为变更是 <code>go build</code> 和 <code>go test</code> 不会自动编辑 <code>go.mod</code> 了，基于以上信息，Go 1.16 中将进行如下处理：</p>
<ul>
<li><p>通过在代码中修改 import 语句，来修改 <code>go.mod</code>：</p>
<ul>
<li><code>go get</code> 可用于添加新模块；</li>
<li><code>go mod tidy</code> 删除掉无用的模块；</li>
</ul>
</li>
<li><p>将未导入的模块写入 <code>go.mod</code>:</p>
<ul>
<li><code>go get &lt;package&gt;[@&lt;version&gt;]</code>;</li>
<li><code>go mod tidy</code> 也可以；</li>
<li>手动编辑；</li>
</ul>
</li>
</ul>
<h3 id="go-work"><a href="#go-work" class="headerlink" title="go work"></a>go work</h3><p>go work机制是1.18版本推出的，是go moudle的最后一块拼图</p>
<p>go work没出来之前的问题：</p>
<ul>
<li>当go.mod中引用的moudle未在github发布，那么go mod tidy时候会报错（多moudle开发的时候经常会遇到这个问题）</li>
</ul>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang包管理</title>
    <url>/2024/09/09/golang/golang%E5%8C%85%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>总结一下go moudle相关内容</p>
<p>golang的包管理经历了GOPATH、go vendor、go moudle三个阶段</p>
<h3 id="GOPATH机制"><a href="#GOPATH机制" class="headerlink" title="GOPATH机制"></a>GOPATH机制</h3><p>golang的package主要分为三种</p>
<ul>
<li>标准库</li>
<li>第三方库</li>
<li>项目私库<br>项目会放在GOPATH&#x2F;src目录下<br>这种方式有一个问题，就是当你有两个项目A、B依赖了同一个第三方库C的不同版本，只能维护两个GOPATH</li>
</ul>
<blockquote>
<p>由于编译器依赖查找固定从GOPATH&#x2F;src下查找<code>GOPATH/src/T</code>，所以，无法在同一个GOPATH目录下保存第三方库T的两个版本</p>
</blockquote>
<p>为了解决这个问题，引入GOVENDOR机制</p>
<h3 id="go-vendor"><a href="#go-vendor" class="headerlink" title="go vendor"></a>go vendor</h3><p>go vendor机制将依赖放在项目目录中，从而隔离了不同项目，不同项目可以引用同一个第三方库的不同版本。<br>但是这会导致两个问题</p>
<p>比如：项目A中依赖了B、C两个第三方库，而B也依赖了C这个库，就会到导致两个问题：</p>
<ol>
<li>C被两次编译进A项目的可执行文件</li>
<li>再进一步，如果两个C的版本不一致，也会有兼容性问题</li>
</ol>
<h3 id="go-moudle"><a href="#go-moudle" class="headerlink" title="go moudle"></a>go moudle</h3><p>在go1.11版本中引入了go moudle机制，它采用了一种全新的设计思想</p>
<p>通过go.mod文件实现</p>
<ol>
<li>准确地记录项目依赖</li>
<li>可重复构建</li>
</ol>
<p>核心是把项目及其依赖抽象成moudle</p>
<h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p>replace用于替换require中出现的包</p>
<p>它正常工作还需要满足两个条件：<br>第一，<code>replace</code>仅在当前module为<code>main module</code>时有效，比如我们当前在编译<code>github.com/renhongcai/gomodule</code>，此时就是<code>main module</code>，如果其他项目引用了<code>github.com/renhongcai/gomodule</code>，那么其他项目编译时，<code>replace</code>就会被自动忽略。</p>
<p>第二，<code>replace</code>指定中<code>=&gt;</code>前面的包及其版本号必须出现在<code>require</code>中才有效，否则指令无效，也会被忽略。 比如，上面的例子中，我们指定<code>replace github.com/google/uuid =&gt; github.com/google/uuid v1.1.0</code>，或者指定<code>replace github.com/google/uuid v1.0.9 =&gt; github.com/google/uuid v1.1.0</code>，二者均都无效。</p>
<h4 id="inderict"><a href="#inderict" class="headerlink" title="inderict"></a>inderict</h4><p>间接引用，比如A引用了B，B引用了C，但是B项目没有采用go moudle管理方式或者缺失go.mod或者go.mod中缺失C，那么在A的go.mod中就会添加C并且后面跟着<br>&#x2F;&#x2F; inderict</p>
<h4 id="go-get与go-install"><a href="#go-get与go-install" class="headerlink" title="go get与go install"></a>go get与go install</h4><p>go get 和 go install 是 Go 语言中的两个常用命令，它们用于获取和安装依赖包或将代码编译为可执行文件。它们的区别如下：</p>
<p>1、go get：</p>
<p>go get 用于获取、更新和安装远程依赖包。它会自动从远程代码库（如 GitHub、GitLab）下载依赖包，并将其安装到 GOPATH 或 GOMOD 目录中。</p>
<p>当您执行 go get 命令时，它会下载指定的包及其依赖项，并将其放置在正确的目录结构中，以供项目引用。</p>
<p>通常，go get 会自动安装依赖项，无需手动执行 go install。</p>
<p>2、go install：</p>
<p>go install 用于编译并安装 Go 语言的可执行程序。它将 Go 代码编译成二进制文件，并将其安装到 GOPATH 或 GOMOD 的 bin 目录中，以供后续执行。</p>
<p>当您执行 go install 命令时，它会在当前包的目录中执行编译过程，并将生成的可执行文件放置在 bin 目录中。</p>
<p>通过 go install 安装的可执行文件可以通过命令行直接运行，无需指定文件路径。</p>
<p>golang的1.16版本之后，go install可以在模块感知的模式下运行，可忽略当前目录或上层目录的 go.mod 文件。这对于在不影响主模块依赖的情况下（不会修改go.mod文件），安装二进制很方便；</p>
<ul>
<li>在将来，go install 被设计为“用于构建和安装二进制文件”， go get 则被设计为 “用于编辑 go.mod 变更依赖”，并且使用时，应该与 <code>-d</code> 参数共用，在将来版本中 <code>-d</code> 可能会默认启用；</li>
<li>非常的简单直观。需要注意的是 go install package@version是从 1.16 开始增加的，无论你当前是否在一个模块下，此命令都会在 <code>$GOPATH/bin</code> 下安装指定版本的工具。</li>
</ul>
<p>go get 将二进制安装相关的功能都转移到了 <code>go install</code>, 仅作为用于编辑 <code>go.mod</code> 文件的命令存在。在后续版本（计划是 Go 1.17）中删掉 <code>go get</code> 安装二进制的功能，接下来 <code>go get</code> 的行为就等同于我们现在执行 <code>go get -d</code> 命令了，仅需下载源码，并将依赖添加至 <code>go.mod</code> 即可。</p>
<p>在 Go 1.16 中，另一个行为变更是 <code>go build</code> 和 <code>go test</code> 不会自动编辑 <code>go.mod</code> 了，基于以上信息，Go 1.16 中将进行如下处理：</p>
<ul>
<li><p>通过在代码中修改 import 语句，来修改 <code>go.mod</code>：</p>
<ul>
<li><code>go get</code> 可用于添加新模块；</li>
<li><code>go mod tidy</code> 删除掉无用的模块；</li>
</ul>
</li>
<li><p>将未导入的模块写入 <code>go.mod</code>:</p>
<ul>
<li><code>go get &lt;package&gt;@&lt;version&gt;</code>;</li>
<li><code>go mod tidy</code> 也可以；</li>
<li>手动编辑；</li>
</ul>
</li>
</ul>
<h3 id="go-work"><a href="#go-work" class="headerlink" title="go work"></a>go work</h3><p>go work机制是1.18版本推出的，是go moudle的最后一块拼图</p>
<p>go work没出来之前的问题：</p>
<ul>
<li>当go.mod中引用的moudle未在github发布，那么go mod tidy时候会报错（多moudle开发的时候经常会遇到这个问题）</li>
</ul>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go work实践</title>
    <url>/2024/10/09/golang/go%20work%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>go work在1.18引入<br>旨在解决本地开发多module场景，传统的go module不优雅的问题</p>
<p>1.18之前</p>
<ul>
<li>当go.mod中引用的moudle未在github发布，那么go mod tidy时候会报错（多moudle开发的时候经常会遇到这个问题）</li>
<li>需要在go.mod文件中进行replace替换成本地包，但是push的时候，有需要将其修改回来<br>引入工作区模式之后：</li>
<li>不需要在go.mod中替换，在go.work文件中替换即可</li>
<li>go.work文件不提交到代码库</li>
</ul>
<p>需要注意的是</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>IDE配置</title>
    <url>/2024/10/22/%E9%9A%8F%E7%AC%94/IDE%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h2><p>打开github copilot chat ：cmd+ctrl+I<br>cw 快速修改文本</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Cmd+D(gb)</td>
<td>选择下一个匹配项，也是选择光标所在单词</td>
</tr>
<tr>
<td>Cmd+K Cmd+D</td>
<td>跳过当前选择项</td>
</tr>
<tr>
<td>cmd+u</td>
<td>回到上一个</td>
</tr>
<tr>
<td>cmd+shift+space</td>
<td>函数提示</td>
</tr>
<tr>
<td>cmd+option+i</td>
<td>结构体字段提示</td>
</tr>
<tr>
<td>shift+方向键</td>
<td>分屏跳转</td>
</tr>
<tr>
<td>cmd+shift+L</td>
<td>多选</td>
</tr>
<tr>
<td>cmd+K cmd+O</td>
<td>显示悬停</td>
</tr>
</tbody></table>
<h2 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h2><p>同时选中修改cmd+f<br>聚焦到编辑器 esc<br>聚焦到project：cmd+1</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>正向代理、反向代理、reverseproxy</title>
    <url>/2024/10/17/web%E5%BC%80%E5%8F%91/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81reverseproxy/</url>
    <content><![CDATA[<p>这里说下我理解的正反向代理与golang的reverse_proxy如何实现代理</p>
<h2 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h2><p>正向代理与反向代理的核心区别在于其目的（或者说作用的对象）</p>
<ul>
<li>正向代理：帮客户端进行请求代理，发给服务器</li>
<li>反向代理，帮服务端处理</li>
</ul>
]]></content>
      <categories>
        <category>web开发</category>
      </categories>
  </entry>
  <entry>
    <title>Go的slice</title>
    <url>/2024/11/16/golang/Go%E7%9A%84slice/</url>
    <content><![CDATA[<p>go的切片，slice[2:4],左闭右开</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>gorm笔记</title>
    <url>/2024/12/11/%E6%95%B0%E6%8D%AE%E5%BA%93/gorm%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2024/11/20/Mysql%E8%A1%A8%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<p>等值连接</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/11/23/redis%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    <content><![CDATA[<h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>读取数据的情况比较简单，先读redis，redis没有的话，再读数据库，之后将数据更新到redis<br><img   src="https://blog-picture-a.oss-cn-shanghai.aliyuncs.com/20241123224837.png"  alt="image.png"></p>
<h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>其实写请求，才是造成大多数一致性问题的原因<br>一般来说，针对写请求有四个策略</p>
<ul>
<li>更新数据库后更新缓存</li>
<li>更新数据库前更新缓存</li>
<li>更新数据库前删除缓存</li>
<li>更新数据库后删除缓存<br>接来来，我们分别说一下这四种情况</li>
</ul>
<h4 id="先更新数据库后更新缓存"><a href="#先更新数据库后更新缓存" class="headerlink" title="先更新数据库后更新缓存"></a>先更新数据库后更新缓存</h4><table>
<thead>
<tr>
<th>时间</th>
<th>线程A（写请求）</th>
<th>线程B（写请求）</th>
<th>问题</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>更新数据库为99</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>更新数据库为98</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>更新缓存数据为98</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td>更新缓存数据为99</td>
<td></td>
<td>此时缓存的值被显式更新为99，但是实际上数据库的值已经是98，数据不一致</td>
</tr>
</tbody></table>
<h4 id="先更新缓存再更新数据库"><a href="#先更新缓存再更新数据库" class="headerlink" title="先更新缓存再更新数据库"></a>先更新缓存再更新数据库</h4><p>这是最不靠谱的一种方案</p>
<p>因为更新数据库不一定成功，如果数据库没有更新成功，那么读到的就不是脏数据了，而是<code>错误数据</code>了</p>
<h4 id="先删除缓存再更新数据库"><a href="#先删除缓存再更新数据库" class="headerlink" title="先删除缓存再更新数据库"></a>先删除缓存再更新数据库</h4><p>这么做，写写并发的时候没有问题，但是读写并发的时候有问题</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>线程A（写请求）</th>
<th>线程B（读请求）</th>
<th>问题</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>删除缓存值</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>1.读取缓存数据，缓存缺失，从数据库读取数据100</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td>更新数据库中的数据X的值为99</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>将数据100的值写入缓存</td>
<td>此时缓存的值被显式更新为100，但是实际上数据库的值已经是99了</td>
</tr>
<tr>
<td>针对这种场景，有个做法是所谓的<strong>“延迟双删策略”</strong>，就是说，既然可能因为读请求把一个旧的值又写回去，那么我在写请求处理完之后，等到差不多的时间延迟再重新删除这个缓存值。</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>时间</th>
<th>线程A（写请求）</th>
<th>线程C（新的读请求）</th>
<th>线程D（新的读请求）</th>
<th>问题</th>
</tr>
</thead>
<tbody><tr>
<td>T5</td>
<td>sleep(N)</td>
<td>缓存存在，读取到缓存旧值100</td>
<td></td>
<td>其他线程可能在双删成功前读到脏数据</td>
</tr>
<tr>
<td>T6</td>
<td>删除缓存值</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>T7</td>
<td></td>
<td></td>
<td>缓存缺失，从数据库读取数据的最新值（99）</td>
<td></td>
</tr>
<tr>
<td>如果N的时间设置得太短，那么删除缓存还是在读线程C更新缓存之前，那么还是脏数据</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="先更新数据库后删除缓存"><a href="#先更新数据库后删除缓存" class="headerlink" title="先更新数据库后删除缓存"></a>先更新数据库后删除缓存</h4>]]></content>
  </entry>
  <entry>
    <title>git笔记</title>
    <url>/2024/11/25/%E9%9A%8F%E7%AC%94/git%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>撤销尚未add的修改：<br>git checkout – filepath</p>
]]></content>
      <categories>
        <category>goframe框架</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql是怎样运行的｜第一章</title>
    <url>/2024/11/19/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%EF%BD%9C%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>mysql</category>
      </categories>
  </entry>
  <entry>
    <title>kafka论文解读</title>
    <url>/2024/12/01/web%E5%BC%80%E5%8F%91/kafka%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="架构详解"><a href="#架构详解" class="headerlink" title="架构详解"></a>架构详解</h2><p>相比rabbitmq等
 </p>
]]></content>
      <categories>
        <category>web开发</category>
      </categories>
  </entry>
  <entry>
    <title>堆结构详解-golang</title>
    <url>/2024/11/25/golang/%E5%A0%86%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>golang没有像java一样提供容器类<br>想要实现堆，要实现heap接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">	sort.Interface</span><br><span class="line">	Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// add x as element Len()</span></span><br><span class="line">	Pop() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// remove and return element Len() - 1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现push和pop，还要实现sort接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Package sort provides primitives for sorting slices and user-defined</span></span><br><span class="line"><span class="comment">// collections.</span></span><br><span class="line"><span class="keyword">package</span> sort</span><br><span class="line"></span><br><span class="line"><span class="comment">// A type, typically a collection, that satisfies sort.Interface can be</span></span><br><span class="line"><span class="comment">// sorted by the routines in this package. The methods require that the</span></span><br><span class="line"><span class="comment">// elements of the collection be enumerated by an integer index.</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">   </span><br><span class="line">	<span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">	Len() <span class="type">int</span></span><br><span class="line">	<span class="comment">// Less reports whether the element with</span></span><br><span class="line">	<span class="comment">// index i should sort before the element with index j.</span></span><br><span class="line">	Less(i, j <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line">	<span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">	Swap(i, j <span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>排序技巧</title>
    <url>/2024/12/16/golang/%E6%8E%92%E5%BA%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>要善用sort包</p>
<p>首先看下之前在堆排序文章中讲的sort接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Interface interface &#123;</span><br><span class="line">	Len() int</span><br><span class="line">	Less(i, j int) bool</span><br><span class="line">	Swap(i, j int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<br>你可以定义一个实现了这个接口的类型</p>
<p>然后比如可以把这个</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title>docker镜像体积优化</title>
    <url>/2024/12/20/kubernetes/docker%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
  </entry>
  <entry>
    <title>rpc相较于http的优势</title>
    <url>/2024/12/23/%E9%A1%B9%E7%9B%AE/rpc%E7%9B%B8%E8%BE%83%E4%BA%8Ehttp%E7%9A%84%E4%BC%98%E5%8A%BF/</url>
    <content><![CDATA[<h1 id="rpc介绍"><a href="#rpc介绍" class="headerlink" title="rpc介绍"></a>rpc介绍</h1>]]></content>
      <categories>
        <category>项目</category>
      </categories>
  </entry>
  <entry>
    <title>项目https协议</title>
    <url>/2024/12/18/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AEhttps%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>证书：</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
  </entry>
  <entry>
    <title>三剑客（pflag、viper、cobra）实践</title>
    <url>/2024/09/13/golang/%E4%B8%89%E5%89%91%E5%AE%A2%EF%BC%88pflag%E3%80%81viper%E3%80%81cobra%EF%BC%89%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="pflag"><a href="#pflag" class="headerlink" title="pflag"></a>pflag</h2><p>比较推荐使用pflag默认提供的flagset-&gt;CommandLine</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String defines a string flag with specified name, default value, and usage string.</span></span><br><span class="line"><span class="comment">// The return value is the address of a string variable that stores the value of the flag.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">String</span><span class="params">(name <span class="type">string</span>, value <span class="type">string</span>, usage <span class="type">string</span>)</span></span> *<span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> CommandLine.StringP(name, <span class="string">&quot;&quot;</span>, value, usage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	name   = pflag.String(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;pcas-aim-be&quot;</span>, <span class="string">&quot;name of the service&quot;</span>)</span><br><span class="line">	help   = pflag.Bool(<span class="string">&quot;help&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;if print help&quot;</span>)</span><br><span class="line">	config = pflag.String(<span class="string">&quot;config&quot;</span>, <span class="string">&quot;/etc/pcas-aim-be/config.yaml&quot;</span>, <span class="string">&quot;config file&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>因此直接使用变量即可<br>同样也可以自定义flagset</p>
<h2 id="Viper"><a href="#Viper" class="headerlink" title="Viper"></a>Viper</h2>]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>进程、线程、协程｜协程池是否必要</title>
    <url>/2025/02/06/golang/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%EF%BD%9C%E5%8D%8F%E7%A8%8B%E6%B1%A0%E6%98%AF%E5%90%A6%E5%BF%85%E8%A6%81/</url>
    <content><![CDATA[<p>首先分别看下进程、线程、协程的定义：</p>
<ol>
<li>进程：每个进程都有自己的独立内存空间，拥有自己独立的地址空间、独立的堆和栈，既不共享堆，亦不共享栈。一个程序至少有一个进程，一个进程至少有一个线程。进程切换只发生在内核态。</li>
<li>线程：拥有自己独立的栈，共享堆内存数据。</li>
</ol>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
  </entry>
</search>
